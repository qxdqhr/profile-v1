////////////////////////////////////////////////////////////////////////////////////////////////
//
//  LocalShadow_ShadowMap.fxsub : LocalShadow シャドウマップ作成
//  ( LocalShadow.fx から呼び出されます．オフスクリーン描画用)
//  作成: 針金P
//
////////////////////////////////////////////////////////////////////////////////////////////////

#define PATOONCONTROLLER "PAToonコントローラー.pmx"


/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
// LocalShadowのパラメーター設定
// セルフ影の設定はここのパラメータを変更してください

// 影生成の計算に用いるデフォルトのライト方向(読み込んだ時の照明方向(X,Y,Z）。モデルが最も見栄えする方向を設定します)
#define LS_InitDirection  float3(-0.5, -0.1, 1.0)

// シャドウマップバッファサイズ（セルフ影マップの解像度、512,1024,2048,4196,8192のどれか）
// コントローラーでぼかせるので小さい数値でもいい。スペックに余裕があるなら大きくした方が楽。

#define LS_ShadowMapBuffSize  2048



// シャドウマップが適用させる範囲サイズ(フェイス部位より少し大きめのサイズを入力します)
#define LS_ShadowMapAreaSize  2.0

// シャドウマップが適用させる深度サイズ(モデル全体より少し大きめのサイズを入力します)
#define LS_ShadowMapDepthLength  20.0

// 影生成の計算に用いるデフォルトのぼかし強度(0〜1で設定,モーフで調整可能なので,ここでは最小値を設定します)
#define LS_InitBlurPower  0

// 陰影が照明操作に連動するデフォルトの割合(0〜1で設定,モーフで調整可能なので,ここでは最小値を設定します)
#define LS_LightSyncShade 0

// 遮蔽影が照明操作に連動するデフォルトの割合(0〜1で設定,モーフで調整可能なので,ここでは最小値を設定します)
#define LS_LightSyncShadow 0

// 遮蔽影の濃度が照明操作に連動するデフォルトの割合(0〜1で設定,モーフで調整可能なので,ここでは最小値を設定します)
#define LS_LightSyncDensity  0



// VSMシャドウマップの実装
#define LS_UseSoftShadow  1
// 0 : 実装しない(ソフトシャドウは使えないけど描画速度は向上する)
// 1 : 実装する(ソフトシャドウが使えるようになります)

// フェイス材質を識別するためのキー数値(材質のキー設定した反射強度を10倍した値の小数部を入力します)
// PAToonではキー数値の設定をなくしているので無効です。
// #define LS_ExecKey  0.39

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////




















//コントローラー計算

float3   LocalShadow_BonePosC     : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "セルフ影"; >;
float4x4 LocalShadow_BoneMatrixC  : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "セルフ影"; >;

float    LocalShadow_MorphLtSyncC : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "Lt陰影連動"; >;

float LocalShadow_MorphSize1C    : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "範囲縮小"; >;
float LocalShadow_MorphSize2C    : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "範囲拡大"; >;
float LocalShadow_MorphSize2XC   : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "X範囲拡大"; >;
float LocalShadow_MorphSize2YC   : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "Y範囲拡大"; >;


float LocalShadow_MorphDist1C    : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "距離近"; >;
float LocalShadow_MorphDist2C    : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "距離遠"; >;

float LocalShadow_MorphLtCtrlC   : CONTROLOBJECT < string name = PATOONCONTROLLER; string item = "Lt影濃調整"; >;
//float LocalShadow_ObjTrC : CONTROLOBJECT < string name = "(self)"; string item = "Tr"; >;




// モデル埋め込みパラメータ
float3   LocalShadow_BonePosM     : CONTROLOBJECT < string name = "(self)"; string item = "セルフ影"; >;
float4x4 LocalShadow_BoneMatrixM  : CONTROLOBJECT < string name = "(self)"; string item = "セルフ影"; >;
float    LocalShadow_MorphLtSyncM : CONTROLOBJECT < string name = "(self)"; string item = "Lt陰影連動"; >;

float LocalShadow_MorphSize1M    : CONTROLOBJECT < string name = "(self)"; string item = "範囲縮小"; >;
float LocalShadow_MorphSize2M    : CONTROLOBJECT < string name = "(self)"; string item = "範囲拡大"; >;
float LocalShadow_MorphSize2XM   : CONTROLOBJECT < string name = "(self)"; string item = "X範囲拡大"; >;
float LocalShadow_MorphSize2YM   : CONTROLOBJECT < string name = "(self)"; string item = "Y範囲拡大"; >;


float LocalShadow_MorphDist1M    : CONTROLOBJECT < string name = "(self)"; string item = "距離近"; >;
float LocalShadow_MorphDist2M    : CONTROLOBJECT < string name = "(self)"; string item = "距離遠"; >;

float LocalShadow_MorphLtCtrlM   : CONTROLOBJECT < string name = "(self)"; string item = "Lt影濃調整"; >;
//float LocalShadow_ObjTrM : CONTROLOBJECT < string name = "(self)"; string item = "Tr"; >;

//パラメータの合算

static float3   LocalShadow_BonePos    = LocalShadow_BonePosC + LocalShadow_BonePosM;
static float4x4 LocalShadow_BoneMatrix = mul(LocalShadow_BoneMatrixC, LocalShadow_BoneMatrixM);

static float    LocalShadow_MorphLtSync = LocalShadow_MorphLtSyncC + LocalShadow_MorphLtSyncM;

static float LocalShadow_MorphSize1  = LocalShadow_MorphSize1C + LocalShadow_MorphSize1M;
static float LocalShadow_MorphSize2  = LocalShadow_MorphSize2C + LocalShadow_MorphSize2M;
static float LocalShadow_MorphSize2X = LocalShadow_MorphSize2XC + LocalShadow_MorphSize2XM;
static float LocalShadow_MorphSize2Y = LocalShadow_MorphSize2YC + LocalShadow_MorphSize2YM;


static float LocalShadow_MorphDist1  = LocalShadow_MorphDist1C + LocalShadow_MorphDist1M;
static float LocalShadow_MorphDist2  = LocalShadow_MorphDist2C +  LocalShadow_MorphDist2M;

static float LocalShadow_MorphLtCtrl = LocalShadow_MorphLtCtrlC + LocalShadow_MorphLtCtrlM;
static float LocalShadow_ObjTr : CONTROLOBJECT < string name = "(self)"; string item = "Tr"; >;

// クォータニオンの積算
float4 LocalShadow_MulQuat(float4 q1, float4 q2)
{
   return float4(cross(q1.xyz, q2.xyz)+q1.xyz*q2.w+q2.xyz*q1.w, q1.w*q2.w-dot(q1.xyz, q2.xyz));
}

// クォータニオンの回転
float3 LocalShadow_RotQuat(float3 v1, float3 v2, float3 pos)
{
   float3 s = cross(v2, v1);
   if( !any(s) ) s = float3(1,0,0);
   float3 v = normalize( s );
   float rot = acos( dot(v1, v2) );
   float sinHD = sin(0.5f * rot);
   float cosHD = cos(0.5f * rot);
   float4 q1 = float4(v*sinHD, cosHD);
   float4 q2 = float4(-v*sinHD, cosHD);
   float4 q = LocalShadow_MulQuat( LocalShadow_MulQuat(q2, float4(pos, 0.0f)), q1);

   return q.xyz;
}

// ライト方向(エフェクト設定方向)
float3 LocalShadow_LtDirection : DIRECTION < string Object = "Light"; >;
static float3 LocalShadow_LtCtrlDir = LocalShadow_RotQuat(float3(0,0.0001,1), normalize(LocalShadow_BoneMatrix._31_32_33), normalize(LS_InitDirection));
static float  LocalShadow_MorphLtSync1 = lerp(LS_LightSyncShade, 1.0f, LocalShadow_MorphLtSync);
static float  LocalShadow_MorphLtSync2 = lerp(LS_LightSyncShadow, 1.0f, LocalShadow_MorphLtSync);
static float3 LocalShadow_LightDirection = normalize(lerp(LocalShadow_LtCtrlDir, LocalShadow_LtDirection, LocalShadow_MorphLtSync2));

// ライト距離
static float LocalShadow_Distance = 15.0f - 14.0f*LocalShadow_MorphDist1 + 85.0f*LocalShadow_MorphDist2;



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 座標変換行列

// ライト方向のビュー変換行列
float4x4 LocalShadow_LightViewMatrix()
{
   // z軸方向ベクトル
   float3 viewZ = LocalShadow_LightDirection;

   // x軸方向ベクトル
   float3 viewX = cross( LocalShadow_BoneMatrix._21_22_23, LocalShadow_LightDirection ); 

   // x軸方向ベクトルの正規化(LookDirとLookUpDirの方向が一致する場合は特異値となる)
   if( !any(viewX) ) viewX = LocalShadow_BoneMatrix._11_21_31;
   viewX = normalize(viewX);

   // y軸方向ベクトル
   float3 viewY = cross( viewZ, viewX );  // 共に垂直なのでこれで正規化

   // ビュー座標変換の回転行列
   float3x3 ltViewRot = float3x3( viewX.x, viewY.x, viewZ.x,
                                  viewX.y, viewY.y, viewZ.y,
                                  viewX.z, viewY.z, viewZ.z );

   // 仮の光源位置
   float3 ltViewPos = LocalShadow_BonePos - LocalShadow_LightDirection * LS_ShadowMapDepthLength;

   // ビュー変換行列
   return float4x4( ltViewRot[0],  0,
                    ltViewRot[1],  0,
                    ltViewRot[2],  0,
                   -mul( ltViewPos, ltViewRot ), 1 );
}


// ライト方向の射影変換行列
float4x4 LocalShadow_LightProjMatrix()
{
//   float s = 2.0f / LS_ShadowMapAreaSize;
//   float s = LS_ShadowMapAreaSize / 3.5f;

//   float d = 0.5f / LS_ShadowMapDepthLength;

//   return float4x4( s, 0, 0, 0,
//                    0, s, 0, 0,
//                    0, 0, d, 0,
//                    0, 0, 0, 1 );

   float sx = 1.0f / (5.0f - 4.0f*LocalShadow_MorphSize1 + 20.0f*LocalShadow_MorphSize2 + 95.0f*LocalShadow_MorphSize2X);
   float sy = 1.0f / (5.0f - 4.0f*LocalShadow_MorphSize1 + 20.0f*LocalShadow_MorphSize2 + 95.0f*LocalShadow_MorphSize2Y);
   float d = 0.5f / LocalShadow_Distance;

   return float4x4( sx, 0,  0, 0,
                    0,  sy, 0, 0,
                    0,  0,  d, 0,
                    0,  0,  0, 1 );

}

float4x4 LocalShadow_WorldMatrix : WORLD;

static float4x4 LocalShadow_LightViewProjMatrix = mul( LocalShadow_LightViewMatrix(), LocalShadow_LightProjMatrix() );
static float4x4 LocalShadow_LightWorldViewProjMatrix = mul( LocalShadow_WorldMatrix, LocalShadow_LightViewProjMatrix );



// 透過値に対する深度読み取り閾値
float AlphaClipThreshold = 0.005;

// マテリアル色
float4 MaterialDiffuse : DIFFUSE  < string Object = "Geometry"; >;

bool opadd; // 加算合成フラグ

// オブジェクトのテクスチャ
texture ObjectTexture: MATERIALTEXTURE;
sampler ObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = LINEAR;
    MAGFILTER = LINEAR;
    MIPFILTER = LINEAR;
    ADDRESSU  = WRAP;
    ADDRESSV  = WRAP;
};


////////////////////////////////////////////////////////////////////////////////////////////////
//MMM対応

#ifndef MIKUMIKUMOVING
    struct VS_INPUT{
        float4 Pos    : POSITION;
        float2 Tex    : TEXCOORD0;
    };
    #define MMM_SKINNING
    #define GETPOS  (IN.Pos)
#else
    #define VS_INPUT  MMM_SKINNING_INPUT
    #define MMM_SKINNING  MMM_SKINNING_OUTPUT SkinOut = MMM_SkinnedPositionNormal(IN.Pos, IN.Normal, IN.BlendWeight, IN.BlendIndices, IN.SdefC, IN.SdefR0, IN.SdefR1);
    #define GETPOS  (SkinOut.Position)
#endif


////////////////////////////////////////////////////////////////////////////////////////////////
// Zプロット描画

struct VS_OUTPUT {
    float4 Pos  : POSITION;    // 射影変換座標
    float4 PPos : TEXCOORD0;   // 射影変換座標
    float2 Tex  : TEXCOORD1;   // テクスチャ
};

// 頂点シェーダ
VS_OUTPUT VS_ShadowMap(VS_INPUT IN)
{
    VS_OUTPUT Out = (VS_OUTPUT)0; 
    MMM_SKINNING

    // ライトの目線によるワールドビュー射影変換をする
    Out.Pos = mul( GETPOS, LocalShadow_LightWorldViewProjMatrix );
    Out.PPos = Out.Pos;

    // テクスチャ座標
    Out.Tex = IN.Tex;

    return Out;
}

// ピクセルシェーダ
float4 PS_ShadowMap(VS_OUTPUT IN, uniform bool useTexture) : COLOR
{
    // α値
    float alpha = MaterialDiffuse.a;

    // α値が0.98の材質はシャドウマップには描画しない
    clip(abs(alpha - 0.98f) - 0.00001f);

    // 加算合成モデルはシャドウマップには描画しない
    clip( !opadd - 0.001f );

    if ( useTexture ) {
        // テクスチャ透過値適用
        alpha *= tex2D( ObjTexSampler, IN.Tex ).a;
    }
    // α値が閾値以下の箇所はシャドウマップには描画しない
    clip(alpha - AlphaClipThreshold);

    // Z値
    float z = saturate(IN.PPos.z / IN.PPos.w);

    return float4(z, 0, 0, 1);
}

///////////////////////////////////////////////////////////////////////////////////////
// テクニック

// オブジェクト描画(セルフシャドウなし)
technique DepthTec0 < string MMDPass = "object"; bool UseTexture = false; >
{
    pass DrawObject {
        AlphaBlendEnable = FALSE;
        VertexShader = compile vs_3_0 VS_ShadowMap();
        PixelShader  = compile ps_3_0 PS_ShadowMap(false);
    }
}

technique DepthTec1 < string MMDPass = "object"; bool UseTexture = true; >
{
    pass DrawObject {
        AlphaBlendEnable = FALSE;
        VertexShader = compile vs_3_0 VS_ShadowMap();
        PixelShader  = compile ps_3_0 PS_ShadowMap(true);
    }
}

// オブジェクト描画(セルフシャドウあり)
technique DepthTecSS0 < string MMDPass = "object_ss"; bool UseTexture = false; >
{
    pass DrawObject {
        AlphaBlendEnable = FALSE;
        VertexShader = compile vs_3_0 VS_ShadowMap();
        PixelShader  = compile ps_3_0 PS_ShadowMap(false);
    }
}

technique DepthTecSS1 < string MMDPass = "object_ss"; bool UseTexture = true; >
{
    pass DrawObject {
        AlphaBlendEnable = FALSE;
        VertexShader = compile vs_3_0 VS_ShadowMap();
        PixelShader  = compile ps_3_0 PS_ShadowMap(true);
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////

// 輪郭は描画しない
technique EdgeTec < string MMDPass = "edge"; > { }
// 地面影は描画しない
technique ShadowTec < string MMDPass = "shadow"; > { }

